package streamer

import (
	"bytes"
	"coordinator/testutil"
	"fmt"
	"github.com/stretchr/testify/assert"
	"io"
	"math/rand"
	"testing"
)

func TestSimpleABStreamingTest(t *testing.T) {
	testLength := 1000000

	testBytes := make([]byte, testLength)
	rand.Read(testBytes)

	ts1 := testutil.CreateSampleSource("foo1", testBytes)

	defer ts1.Close()

	ts2 := testutil.CreateSampleSink("foo2")
	defer ts2.Close()

	var gotGetNotify = 0
	var gotPostNotify = 0
	var gotGetDone = false
	var getDoneOutBytes int64 = 0
	var gotPostDone = false
	var postPostInBytes int64 = 0

	var getNotify StreamNotifyFn = func(reqId int, in int64, out int64, inFailure error, done bool) {
		gotGetNotify++
		if done {
			gotGetDone = true
			assert.NoError(t, inFailure)
			getDoneOutBytes = out
		}
	}

	var postNotify StreamNotifyFn = func(reqId int, in int64, out int64, inFailure error, done bool) {
		gotPostNotify++
		if done {
			gotPostDone = true
			assert.NoError(t, inFailure)
			postPostInBytes = in
		}
	}

	contentType := "foo"

	getSource, err := CreateHttpGetSource(ts1.ResourceUrl(), &contentType, getNotify)
	assert.NoError(t, err)
	postSink, err := CreateHttpPostSink(fmt.Sprintf("localhost:%d", getSource.Port), ts2.ResourceUrl(), &contentType, postNotify)
	assert.NoError(t, err)

	postSink.Wait()
	assert.Equal(t, 1, ts1.Requests)
	assert.Equal(t, 1, ts2.Requests)
	assert.Equal(t, contentType, ts1.MimeTypes[0])
	assert.Equal(t, contentType, ts2.MimeTypes[0])
	assert.True(t, gotGetNotify == 1) // no notifications, only one
	assert.True(t, gotPostNotify == 1)
	assert.True(t, gotGetDone)
	assert.True(t, gotPostDone)
	assert.Equal(t, int64(testLength), getDoneOutBytes)
	assert.Equal(t, int64(testLength), postPostInBytes)
	assert.Equal(t, testBytes, ts2.RequestData[0])
}

type randReader struct {
	generated bytes.Buffer
}

func (r *randReader) Read(p []byte) (n int, err error) {
	n, err = rand.Read(p)
	if err != nil {
		return
	}
	r.generated.Write(p)
	return n, err
}

func TestTransformation(t *testing.T) {
	testLength := int64(100000)
	var reader randReader

	limitedSource := io.LimitReader(&reader, testLength)

	netSource := testutil.CreateSampleTcpSource(limitedSource)

	ts := testutil.CreateSampleTransformation("foo")

	var gotDone = 0

	var postNotify StreamNotifyFn = func(reqId int, in int64, out int64, inFailure error, done bool) {
		assert.NoError(t, inFailure)
		assert.Equal(t, 0, reqId)
		if done {
			gotDone++
			assert.Equal(t, testLength, in)
			assert.Equal(t, testLength, out)
		}
	}
	contentType := "application/boom"
	transformation, err := CreateHttpPostTransformation(netSource.FullAddress(), ts.ResourceUrl(), &contentType, postNotify)
	assert.NoError(t, err)

	bytes, err := testutil.TcpPullData(fmt.Sprintf("localhost:%d", transformation.Port))
	assert.NoError(t, err)
	assert.Equal(t, reader.generated.Bytes(), bytes)
	assert.Equal(t, 1, gotDone)
	assert.Equal(t, contentType, ts.MimeTypes[0])
}
