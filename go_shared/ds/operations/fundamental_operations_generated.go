package operations

// Note: this code is generated by gen/operations.go
// Any changes will be overwritten

import (
	"github.com/mantik-ai/core/go_shared/ds"
	"github.com/mantik-ai/core/go_shared/ds/element"
	"github.com/pkg/errors"
)

func lookupFundamentalEquals(ft *ds.FundamentalType) (EqualsOperation, error) {
	var result EqualsOperation
	switch ft {

	case ds.Bool:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(bool) == r.(element.Primitive).X.(bool)
		}

	case ds.Float32:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(float32) == r.(element.Primitive).X.(float32)
		}

	case ds.Float64:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(float64) == r.(element.Primitive).X.(float64)
		}

	case ds.Int32:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(int32) == r.(element.Primitive).X.(int32)
		}

	case ds.Int64:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(int64) == r.(element.Primitive).X.(int64)
		}

	case ds.Int8:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(int8) == r.(element.Primitive).X.(int8)
		}

	case ds.String:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(string) == r.(element.Primitive).X.(string)
		}

	case ds.Uint32:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(uint32) == r.(element.Primitive).X.(uint32)
		}

	case ds.Uint64:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(uint64) == r.(element.Primitive).X.(uint64)
		}

	case ds.Uint8:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(uint8) == r.(element.Primitive).X.(uint8)
		}

	case ds.Void:
		result = func(l element.Element, r element.Element) bool {
			return l.(element.Primitive).X.(interface{}) == r.(element.Primitive).X.(interface{})
		}

	default:
		return nil, errors.Errorf("No raw equals available for %s", ft.TypeName())
	}
	return result, nil
}

func lookupTensorEquals(ft *ds.FundamentalType) (EqualsOperation, error) {
	var result EqualsOperation
	switch ft {

	case ds.Bool:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]bool)
			rs := r.(*element.TensorElement).Values.([]bool)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Float32:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]float32)
			rs := r.(*element.TensorElement).Values.([]float32)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Float64:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]float64)
			rs := r.(*element.TensorElement).Values.([]float64)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Int32:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]int32)
			rs := r.(*element.TensorElement).Values.([]int32)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Int64:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]int64)
			rs := r.(*element.TensorElement).Values.([]int64)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Int8:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]int8)
			rs := r.(*element.TensorElement).Values.([]int8)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.String:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]string)
			rs := r.(*element.TensorElement).Values.([]string)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Uint32:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]uint32)
			rs := r.(*element.TensorElement).Values.([]uint32)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Uint64:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]uint64)
			rs := r.(*element.TensorElement).Values.([]uint64)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Uint8:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]uint8)
			rs := r.(*element.TensorElement).Values.([]uint8)
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	case ds.Void:
		result = func(l element.Element, r element.Element) bool {
			ls := l.(*element.TensorElement).Values.([]interface{})
			rs := r.(*element.TensorElement).Values.([]interface{})
			if (ls == nil) != (rs == nil) {
				return false
			}
			if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
				if ls[i] != rs[i] {
					return false
				}
			}
			return true
		}

	default:
		return nil, errors.Errorf("No tensor equals available for %s", ft.TypeName())
	}
	return result, nil
}

func lookupFundamentalBinaryFunction(op BinaryOperation, ft *ds.FundamentalType) (BinaryFunction, error) {
	var result BinaryFunction
	switch ft {

	case ds.Uint8:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint8)
				rs := r.(element.Primitive).X.(uint8)
				x := (uint8)(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint8)
				rs := r.(element.Primitive).X.(uint8)
				x := (uint8)(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint8)
				rs := r.(element.Primitive).X.(uint8)
				x := (uint8)(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint8)
				rs := r.(element.Primitive).X.(uint8)
				x := (uint8)(ls / rs)
				return element.Primitive{X: x}
			}
		}

	case ds.Int8:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int8)
				rs := r.(element.Primitive).X.(int8)
				x := (int8)(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int8)
				rs := r.(element.Primitive).X.(int8)
				x := (int8)(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int8)
				rs := r.(element.Primitive).X.(int8)
				x := (int8)(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int8)
				rs := r.(element.Primitive).X.(int8)
				x := (int8)(ls / rs)
				return element.Primitive{X: x}
			}
		}

	case ds.Uint32:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint32)
				rs := r.(element.Primitive).X.(uint32)
				x := (uint32)(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint32)
				rs := r.(element.Primitive).X.(uint32)
				x := (uint32)(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint32)
				rs := r.(element.Primitive).X.(uint32)
				x := (uint32)(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint32)
				rs := r.(element.Primitive).X.(uint32)
				x := (uint32)(ls / rs)
				return element.Primitive{X: x}
			}
		}

	case ds.Int32:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int32)
				rs := r.(element.Primitive).X.(int32)
				x := (int32)(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int32)
				rs := r.(element.Primitive).X.(int32)
				x := (int32)(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int32)
				rs := r.(element.Primitive).X.(int32)
				x := (int32)(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int32)
				rs := r.(element.Primitive).X.(int32)
				x := (int32)(ls / rs)
				return element.Primitive{X: x}
			}
		}

	case ds.Uint64:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint64)
				rs := r.(element.Primitive).X.(uint64)
				x := (uint64)(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint64)
				rs := r.(element.Primitive).X.(uint64)
				x := (uint64)(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint64)
				rs := r.(element.Primitive).X.(uint64)
				x := (uint64)(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(uint64)
				rs := r.(element.Primitive).X.(uint64)
				x := (uint64)(ls / rs)
				return element.Primitive{X: x}
			}
		}

	case ds.Int64:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int64)
				rs := r.(element.Primitive).X.(int64)
				x := (int64)(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int64)
				rs := r.(element.Primitive).X.(int64)
				x := (int64)(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int64)
				rs := r.(element.Primitive).X.(int64)
				x := (int64)(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(int64)
				rs := r.(element.Primitive).X.(int64)
				x := (int64)(ls / rs)
				return element.Primitive{X: x}
			}
		}

	case ds.Float32:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(float32)
				rs := r.(element.Primitive).X.(float32)
				x := (float32)(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(float32)
				rs := r.(element.Primitive).X.(float32)
				x := (float32)(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(float32)
				rs := r.(element.Primitive).X.(float32)
				x := (float32)(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(float32)
				rs := r.(element.Primitive).X.(float32)
				x := (float32)(ls / rs)
				return element.Primitive{X: x}
			}
		}

	case ds.Float64:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(float64)
				rs := r.(element.Primitive).X.(float64)
				x := (float64)(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(float64)
				rs := r.(element.Primitive).X.(float64)
				x := (float64)(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(float64)
				rs := r.(element.Primitive).X.(float64)
				x := (float64)(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.(float64)
				rs := r.(element.Primitive).X.(float64)
				x := (float64)(ls / rs)
				return element.Primitive{X: x}
			}
		}

	default:
		return nil, errors.Errorf("No raw binary functions available for %s", ft.TypeName())
	}
	return result, nil
}
