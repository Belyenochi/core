/*
 * This file is part of the Mantik Project.
 * Copyright (c) 2020-2021 Mantik UG (Haftungsbeschr√§nkt)
 * Authors: See AUTHORS file
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.
 *
 * Additionally, the following linking exception is granted:
 *
 * If you modify this Program, or any covered work, by linking or
 * combining it with other code, such other code is not for that reason
 * alone subject to any of the requirements of the GNU Affero GPL
 * version 3.
 *
 * You can be released from the requirements of the license by purchasing
 * a commercial license.
 */
package main

import (
	"fmt"
	"os"
	"text/template"
)

// Maps ds Types to Go Types.
var dsTypeMapping = map[string]string{
	"Uint8":   "uint8",
	"Int8":    "int8",
	"Uint32":  "uint32",
	"Int32":   "int32",
	"Uint64":  "uint64",
	"Int64":   "int64",
	"String":  "string",
	"Bool":    "bool",
	"Float32": "float32",
	"Float64": "float64",
	"Void":    "interface{}",
}

// Types for which binary operations are created.
var binaryOperationTypes = struct {
	TypeMapping map[string]string
	Types       []string
}{
	TypeMapping: dsTypeMapping,
	Types:       []string{"Uint8", "Int8", "Uint32", "Int32", "Uint64", "Int64", "Float32", "Float64"},
}

func main() {
	lookupTemplate := template.Must(template.New("lookupTemplate").Parse(lookupFunction))
	fmt.Print(header)
	tensorTemplate := template.Must(template.New("tensorTemplate").Parse(lookupTensorFunction))

	binaryTemplate := template.Must(template.New("binaryTemplate").Parse(lookupBinaryFunction))

	err := lookupTemplate.Execute(os.Stdout, dsTypeMapping)
	if err == nil {
		err = tensorTemplate.Execute(os.Stdout, dsTypeMapping)
	}
	if err == nil {
		err = binaryTemplate.Execute(os.Stdout, binaryOperationTypes)
	}
	if err != nil {
		fmt.Fprintf(os.Stderr, "Something failed %s", err.Error())
		os.Exit(1)
	}
}

var header = `package operations

// Note: this code is generated by gen/operations.go
// Any changes will be overwritten

import (
	"github.com/pkg/errors"
	"gl.ambrosys.de/mantik/go_shared/ds"
	"gl.ambrosys.de/mantik/go_shared/ds/element"
)

`

var lookupFunction = `
func lookupFundamentalEquals(ft * ds.FundamentalType) (EqualsOperation, error) {
	var result EqualsOperation
	switch ft {
	{{ range $ft, $goType := $ }}
	case ds.{{ $ft }}:
		result = func(l element.Element, r element.Element) bool {
          return l.(element.Primitive).X.({{ $goType }}) == r.(element.Primitive).X.({{ $goType }}) 
        }
	{{ end }}
	default:
		return nil, errors.Errorf("No raw equals available for %s", ft.TypeName())
	}
	return result, nil
}
`

var lookupTensorFunction = `
func lookupTensorEquals(ft * ds.FundamentalType) (EqualsOperation, error) {
	var result EqualsOperation
	switch ft {
	{{ range $ft, $goType := $ }}
	case ds.{{ $ft }}:
		result = func(l element.Element, r element.Element) bool {
          	ls := l.(*element.TensorElement).Values.([]{{ $goType }})
			rs := r.(*element.TensorElement).Values.([]{{ $goType }})
			if (ls == nil) != (rs == nil){
				return false
			}
            if len(ls) != len(rs) {
				return false
			}
			for i := range ls {
                if ls[i] != rs[i] {
					return false
				}
			}
			return true
        }
	{{ end }}
	default:
		return nil, errors.Errorf("No tensor equals available for %s", ft.TypeName())
	}
	return result, nil
}
`

var lookupBinaryFunction = `
func lookupFundamentalBinaryFunction(op BinaryOperation, ft * ds.FundamentalType) (BinaryFunction, error) {
	var result BinaryFunction
	switch ft {
	{{ range $ft := $.Types }}
	case ds.{{ $ft }}:
		switch op {
		case AddCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.({{index $.TypeMapping $ft }})
				rs := r.(element.Primitive).X.({{index $.TypeMapping $ft }})
				x := ({{index $.TypeMapping $ft}})(ls + rs)
				return element.Primitive{X: x}
			}
		case SubCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.({{index $.TypeMapping $ft }})
				rs := r.(element.Primitive).X.({{index $.TypeMapping $ft }})
				x := ({{index $.TypeMapping $ft}})(ls - rs)
				return element.Primitive{X: x}
			}
		case MulCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.({{index $.TypeMapping $ft }})
				rs := r.(element.Primitive).X.({{index $.TypeMapping $ft }})
				x := ({{index $.TypeMapping $ft}})(ls * rs)
				return element.Primitive{X: x}
			}
		case DivCode:
			result = func(l element.Element, r element.Element) element.Element {
				ls := l.(element.Primitive).X.({{index $.TypeMapping $ft }})
				rs := r.(element.Primitive).X.({{index $.TypeMapping $ft }})
				x := ({{index $.TypeMapping $ft}})(ls / rs)
				return element.Primitive{X: x}
			}
		}
	{{ end }}
	default:
		return nil, errors.Errorf("No raw binary functions available for %s", ft.TypeName())
	}
	return result, nil
}
 
`
