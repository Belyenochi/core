/*
 * This file is part of the Mantik Project.
 * Copyright (c) 2020-2021 Mantik UG (Haftungsbeschr√§nkt)
 * Authors: See AUTHORS file
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.
 *
 * Additionally, the following linking exception is granted:
 *
 * If you modify this Program, or any covered work, by linking or
 * combining it with other code, such other code is not for that reason
 * alone subject to any of the requirements of the GNU Affero GPL
 * version 3.
 *
 * You can be released from the requirements of the license by purchasing
 * a commercial license.
 */
package main

import (
	"fmt"
	"os"
	"text/template"
)

var dsTypeMapping = map[string]string{
	"Uint8":   "uint8",
	"Int8":    "int8",
	"Uint32":  "uint32",
	"Int32":   "int32",
	"Uint64":  "uint64",
	"Int64":   "int64",
	"Float32": "float32",
	"Float64": "float64",
}

type dsTypeConverter struct {
	From string
	// The types which can be translated from from with lossless conversion
	To []string
	// The types which can be translated from from with lossy conversion
	Lossy []string
}

func MakeConverter(from string, lossless ...string) dsTypeConverter {
	var loosing []string
	for typeName := range dsTypeMapping {
		if !contains(typeName, lossless) {
			loosing = append(loosing, typeName)
		}
	}
	return dsTypeConverter{
		from, lossless, loosing,
	}
}

type dsTypeConverterWithMapping struct {
	Converters  []dsTypeConverter
	TypeMapping map[string]string
}

// Available converters

var converters = []dsTypeConverter{
	MakeConverter("Uint8", "Int32", "Uint32", "Int64", "Uint64", "Float32", "Float64"),
	MakeConverter("Int8", "Int32", "Int64", "Float32", "Float64"),
	MakeConverter("Uint32", "Uint64", "Int64", "Float64"),
	MakeConverter("Int32", "Int64", "Float64"),
	MakeConverter("Uint64"),
	MakeConverter("Int64"),
	MakeConverter("Float32", "Float64"),
	MakeConverter("Float64"),
}

var convertsWithMapping = dsTypeConverterWithMapping{converters, dsTypeMapping}

func contains(s string, list []string) bool {
	for _, e := range list {
		if e == s {
			return true
		}
	}
	return false
}

func main() {
	lookupTemplate := template.Must(template.New("lookupTemplate").Parse(lookupFunction))
	fmt.Print(header)

	err := lookupTemplate.Execute(os.Stdout, convertsWithMapping)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Something failed %s", err.Error())
		os.Exit(1)
	}
}

var header = `package adapt

// Note: this code is generated by gen/raw_converters.go
// Any changes will be overwritten

import (
	"github.com/pkg/errors"
	"gl.ambrosys.de/mantik/go_shared/ds"
)

`

var lookupFunction = `
func LookupRawAdapter(from *ds.FundamentalType, to *ds.FundamentalType) (RawAdapter, error) {
	if from == to {
		return emptyRawAdapter, nil
	}
	var result RawAdapter
	switch from {
	{{ range $from, $value := $.Converters }}
	case ds.{{ $value.From }}:
		switch to {
		{{ range $to, $toValue := $value.To }}
			case ds.{{ $toValue }}:
				result = func(i interface{}) interface{} {
					return {{ index $.TypeMapping $toValue }}(i.({{ index $.TypeMapping $value.From }}))
				}
		{{ end }}
		default:
			return nil, errors.Errorf("No raw converter from %s to %s", from.TypeName(), to.TypeName())
		}
	{{ end }}
	default:
		return nil, errors.Errorf("No raw converter from %s", from.TypeName())
	}
	return result, nil
}

func LookupLossyRawAdapter(from * ds.FundamentalType, to * ds.FundamentalType) (RawAdapter, error) {
	if from == to {
		return emptyRawAdapter, nil
	}
	var result RawAdapter
	switch from {
	{{ range $from, $value := $.Converters }}
	case ds.{{ $value.From }}:
		switch to {
		{{ range $to, $toValue := $value.Lossy }}
			case ds.{{ $toValue }}:
				result = func(i interface{}) interface{} {
					return {{ index $.TypeMapping $toValue }}(i.({{ index $.TypeMapping $value.From }}))
				}
		{{ end }}
		default:
			return nil, errors.Errorf("No raw converter from %s to %s", from.TypeName(), to.TypeName())
		}
	{{ end }}
	default:
		return nil, errors.Errorf("No raw converter from %s", from.TypeName())
	}
	return result, nil
}
`
