package main

import (
	"fmt"
	"os"
	"text/template"
)

type generatorType struct {
	DsTypeName string
	CodecName  string
	GoTypeName string
	EncodeName string
	DecodeName string
}

var types = []generatorType{
	{"Int8", "int8Codec", "int8", "EncodeInt8", "DecodeInt8"},
	{"Uint8", "uint8Codec", "uint8", "EncodeUint8", "DecodeUint8"},
	{"Int32", "int32Codec", "int32", "EncodeInt32", "DecodeInt32"},
	{"Uint32", "uint32Codec", "uint32", "EncodeUint32", "DecodeUint32"},
	{"Int64", "int64Codec", "int64", "EncodeInt64", "DecodeInt64"},
	{"Uint64", "uint64Codec", "uint64", "EncodeUint64", "DecodeUint64"},
	{"String", "stringCodec", "string", "EncodeString", "DecodeString"},
	{"Float32", "float32Codec", "float32", "EncodeFloat32", "DecodeFloat32"},
	{"Float64", "float64Codec", "float64", "EncodeFloat64", "DecodeFloat64"},
	{"Bool", "boolCodec", "bool", "EncodeBool", "DecodeBool"},
}

func main() {
	lookupTemplate := template.Must(template.New("lookupTemplate").Parse(lookupFunction))
	codecTemplate := template.Must(template.New("codecTemplate").Parse(codeTemplate))
	fmt.Print(header)

	err := lookupTemplate.Execute(os.Stdout, types)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Something failed %s", err.Error())
		os.Exit(1)
	}

	for _, dtype := range types {
		err := codecTemplate.Execute(os.Stdout, dtype)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Something failed %s", err.Error())
			os.Exit(1)
		}
	}
}

var header = `package natural

// Note: this code is generated by gen/fundamentals.go
// Any changes will be overwritten

import (
	"github.com/pkg/errors"
	"gl.ambrosys.de/mantik/go_shared/ds"
	"gl.ambrosys.de/mantik/go_shared/ds/util/serializer"
)
`

var lookupFunction = `
func GetFundamentalCodec(dataType ds.DataType) (FundamentalCodec, error) {
	if !dataType.IsFundamental(){
		return nil, errors.New("Expected fundamental codec")
	}
	var result FundamentalCodec
	switch dataType {
	{{ range $key, $value := . }}
    case ds.{{ $value.DsTypeName }}:
      result = {{ $value.CodecName }} {}
    {{ end }}
	default:
		return nil, errors.Errorf("Implementation missing for %s", dataType.TypeName())
	}
	return result, nil
}
`

var codeTemplate = `
type {{.CodecName}} struct {}

func ({{.CodecName}}) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok :=  value.({{.GoTypeName}})
	if !ok {
		return badType
	}
	return backend.{{.EncodeName}}(i)
}

func ({{.CodecName}}) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]{{.GoTypeName}})
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.{{.EncodeName}}(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func ({{.CodecName}}) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.{{.DecodeName}}()
}

func ({{.CodecName}}) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]{{.GoTypeName}}, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.{{.DecodeName}}()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

`
