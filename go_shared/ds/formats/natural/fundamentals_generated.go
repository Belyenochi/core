package natural

// Note: this code is generated by gen/fundamentals.go
// Any changes will be overwritten

import (
	"github.com/pkg/errors"
	"gl.ambrosys.de/mantik/go_shared/ds"
	"gl.ambrosys.de/mantik/go_shared/ds/util/serializer"
)

func GetFundamentalCodec(dataType ds.DataType) (FundamentalCodec, error) {
	if !dataType.IsFundamental() {
		return nil, errors.New("Expected fundamental codec")
	}
	var result FundamentalCodec
	switch dataType {

	case ds.Int8:
		result = int8Codec{}

	case ds.Uint8:
		result = uint8Codec{}

	case ds.Int32:
		result = int32Codec{}

	case ds.Uint32:
		result = uint32Codec{}

	case ds.Int64:
		result = int64Codec{}

	case ds.Uint64:
		result = uint64Codec{}

	case ds.String:
		result = stringCodec{}

	case ds.Float32:
		result = float32Codec{}

	case ds.Float64:
		result = float64Codec{}

	case ds.Bool:
		result = boolCodec{}

	default:
		return nil, errors.Errorf("Implementation missing for %s", dataType.TypeName())
	}
	return result, nil
}

type int8Codec struct{}

func (int8Codec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(int8)
	if !ok {
		return badType
	}
	return backend.EncodeInt8(i)
}

func (int8Codec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]int8)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeInt8(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (int8Codec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeInt8()
}

func (int8Codec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]int8, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeInt8()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (int8Codec) Compare(left interface{}, right interface{}) int {
	lc := left.(int8)
	rc := right.(int8)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c int8Codec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]int8)
	rc := right.([]int8)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type uint8Codec struct{}

func (uint8Codec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(uint8)
	if !ok {
		return badType
	}
	return backend.EncodeUint8(i)
}

func (uint8Codec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]uint8)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeUint8(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (uint8Codec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeUint8()
}

func (uint8Codec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]uint8, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeUint8()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (uint8Codec) Compare(left interface{}, right interface{}) int {
	lc := left.(uint8)
	rc := right.(uint8)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c uint8Codec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]uint8)
	rc := right.([]uint8)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type int32Codec struct{}

func (int32Codec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(int32)
	if !ok {
		return badType
	}
	return backend.EncodeInt32(i)
}

func (int32Codec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]int32)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeInt32(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (int32Codec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeInt32()
}

func (int32Codec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]int32, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeInt32()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (int32Codec) Compare(left interface{}, right interface{}) int {
	lc := left.(int32)
	rc := right.(int32)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c int32Codec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]int32)
	rc := right.([]int32)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type uint32Codec struct{}

func (uint32Codec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(uint32)
	if !ok {
		return badType
	}
	return backend.EncodeUint32(i)
}

func (uint32Codec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]uint32)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeUint32(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (uint32Codec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeUint32()
}

func (uint32Codec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]uint32, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeUint32()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (uint32Codec) Compare(left interface{}, right interface{}) int {
	lc := left.(uint32)
	rc := right.(uint32)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c uint32Codec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]uint32)
	rc := right.([]uint32)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type int64Codec struct{}

func (int64Codec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(int64)
	if !ok {
		return badType
	}
	return backend.EncodeInt64(i)
}

func (int64Codec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]int64)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeInt64(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (int64Codec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeInt64()
}

func (int64Codec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]int64, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeInt64()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (int64Codec) Compare(left interface{}, right interface{}) int {
	lc := left.(int64)
	rc := right.(int64)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c int64Codec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]int64)
	rc := right.([]int64)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type uint64Codec struct{}

func (uint64Codec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(uint64)
	if !ok {
		return badType
	}
	return backend.EncodeUint64(i)
}

func (uint64Codec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]uint64)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeUint64(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (uint64Codec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeUint64()
}

func (uint64Codec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]uint64, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeUint64()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (uint64Codec) Compare(left interface{}, right interface{}) int {
	lc := left.(uint64)
	rc := right.(uint64)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c uint64Codec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]uint64)
	rc := right.([]uint64)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type stringCodec struct{}

func (stringCodec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(string)
	if !ok {
		return badType
	}
	return backend.EncodeString(i)
}

func (stringCodec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]string)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeString(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (stringCodec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeString()
}

func (stringCodec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]string, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeString()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (stringCodec) Compare(left interface{}, right interface{}) int {
	lc := left.(string)
	rc := right.(string)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c stringCodec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]string)
	rc := right.([]string)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type float32Codec struct{}

func (float32Codec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(float32)
	if !ok {
		return badType
	}
	return backend.EncodeFloat32(i)
}

func (float32Codec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]float32)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeFloat32(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (float32Codec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeFloat32()
}

func (float32Codec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]float32, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeFloat32()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (float32Codec) Compare(left interface{}, right interface{}) int {
	lc := left.(float32)
	rc := right.(float32)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c float32Codec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]float32)
	rc := right.([]float32)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type float64Codec struct{}

func (float64Codec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(float64)
	if !ok {
		return badType
	}
	return backend.EncodeFloat64(i)
}

func (float64Codec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]float64)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeFloat64(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (float64Codec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeFloat64()
}

func (float64Codec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]float64, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeFloat64()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (float64Codec) Compare(left interface{}, right interface{}) int {
	lc := left.(float64)
	rc := right.(float64)
	if lc < rc {
		return -1
	} else if lc > rc {
		return +1
	} else {
		return 0
	}
}

func (c float64Codec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]float64)
	rc := right.([]float64)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}

type boolCodec struct{}

func (boolCodec) Write(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.(bool)
	if !ok {
		return badType
	}
	return backend.EncodeBool(i)
}

func (boolCodec) WriteArray(backend serializer.SerializingBackend, value interface{}) error {
	i, ok := value.([]bool)
	if !ok {
		return badType
	}
	err := backend.EncodeArrayLen(len(i))
	if err != nil {
		return err
	}
	for _, v := range i {
		err := backend.EncodeBool(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (boolCodec) Read(backend serializer.DeserializingBackend) (interface{}, error) {
	return backend.DecodeBool()
}

func (boolCodec) ReadArray(backend serializer.DeserializingBackend) (interface{}, error) {
	alen, err := backend.DecodeArrayLen()
	if err != nil {
		return nil, err
	}
	result := make([]bool, alen)
	for i := 0; i < alen; i++ {
		v, err := backend.DecodeBool()
		if err != nil {
			return nil, err
		}
		result[i] = v
	}
	return result, nil
}

func (c boolCodec) CompareArray(left interface{}, right interface{}) int {
	lc := left.([]bool)
	rc := right.([]bool)
	if len(lc) < len(rc) {
		return -1
	}
	if len(lc) > len(rc) {
		return 1
	}
	for i, lv := range lc {
		cmp := c.Compare(lv, rc[i])
		if cmp != 0 {
			return cmp
		}
	}
	return 0
}
